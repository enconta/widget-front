{"ast":null,"code":"import _defineProperty from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport moment from 'moment';\nimport { LAST_PERIOD_KEY, LAST_YEAR_KEY, PERIODS } from '../../constants';\nimport { PERIOD_FORMAT } from 'utils';\nvar PERIOD = PERIODS.reduce(function (acc, ac) {\n  return _objectSpread({}, acc, _defineProperty({}, ac.id, ac.months));\n}, {});\n/**\n * Calculates dates based on filters\n * @param  {String} month\n * @param  {String} period\n * @param  {String} range\n * @param  {Number} year\n * @returns {Object} moment objects with last range and current range\n */\n\nexport var calculateDates = function calculateDates(_ref) {\n  var month = _ref.month,\n      period = _ref.period,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? LAST_YEAR_KEY : _ref$range,\n      year = _ref.year;\n  var calculatedPeriod = PERIOD[period] - 1;\n  var lastStartMonth;\n  var lastEndMonth;\n  var endMonth = moment().set('year', year).set('month', month - 1); // Months on moment start at 0\n\n  var startMonth = moment(endMonth).subtract(calculatedPeriod, 'month');\n\n  if (range === LAST_YEAR_KEY) {\n    lastEndMonth = moment(endMonth).subtract(1, 'year');\n    lastStartMonth = moment(lastEndMonth).subtract(calculatedPeriod, 'month');\n  } else if (range === LAST_PERIOD_KEY) {\n    lastEndMonth = moment(startMonth).subtract(1, 'month');\n    lastStartMonth = moment(lastEndMonth).subtract(calculatedPeriod, 'month');\n  } else {\n    lastEndMonth = endMonth;\n    lastStartMonth = startMonth;\n  }\n\n  return {\n    lastStartMonth: lastStartMonth,\n    lastEndMonth: lastEndMonth,\n    startMonth: startMonth,\n    endMonth: endMonth\n  };\n};\n/**\n * Calculate dates to query based on filters\n * @param  {string} month\n * @param  {string} period\n * @param  {string} range\n * @param  {number} year\n * @param  {string} type\n * @returns {Object<String>} Return object with string required for request\n */\n\nexport var calculateQuery = function calculateQuery(_ref2) {\n  var month = _ref2.month,\n      period = _ref2.period,\n      range = _ref2.range,\n      year = _ref2.year,\n      type = _ref2.type;\n\n  var _calculateDates = calculateDates({\n    month: month,\n    period: period,\n    range: range,\n    year: year\n  }),\n      lastStartMonth = _calculateDates.lastStartMonth,\n      lastEndMonth = _calculateDates.lastEndMonth,\n      startMonth = _calculateDates.startMonth,\n      endMonth = _calculateDates.endMonth;\n\n  return {\n    type: type,\n    start_month: startMonth.format(PERIOD_FORMAT),\n    end_month: endMonth.format(PERIOD_FORMAT),\n    last_start_month: lastStartMonth.format(PERIOD_FORMAT),\n    last_end_month: lastEndMonth.format(PERIOD_FORMAT)\n  };\n};\n/**\n * HOF returns a function to map, calculates position based on last report\n * @param  {Object} item\n * @param  {number} index\n */\n\nexport var calculatePositions = function calculatePositions(lastReport) {\n  return function (item, index) {\n    // find for index use client_id\n    var lastIndex = lastReport.findIndex(function (lastItem) {\n      return lastItem.client_id === item.client_id;\n    }); // if not find in lastreport, js returns -1\n\n    var hasLast = lastIndex !== -1;\n    return {\n      clientId: item.client_id,\n      legalName: item.legal_name,\n      currentTotalCents: item.total,\n      lastPosition: hasLast ? lastIndex + 1 : null,\n      lastTotalCents: hasLast ? lastReport[lastIndex].total : null\n    };\n  };\n};\n/**\n * Calculate index movement based, and return icon and number steps moved\n * @param  {number} currentIndex\n * @param  {number} lastIndex\n */\n\nexport var calculateChange = function calculateChange(currentIndex, lastIndex) {\n  if (lastIndex === null) {\n    return {\n      icon: 'not',\n      steps: ''\n    };\n  }\n\n  if (currentIndex === lastIndex) {\n    return {\n      icon: 'hold',\n      steps: ''\n    };\n  } else if (currentIndex > lastIndex) {\n    return {\n      icon: 'down',\n      steps: currentIndex - lastIndex\n    };\n  } else if (currentIndex < lastIndex) {\n    return {\n      icon: 'up',\n      steps: lastIndex - currentIndex\n    };\n  }\n};","map":{"version":3,"sources":["/Users/usuario-rtd/Desktop/widget-front/src/components/app/views/reports/rankings/utils/index.js"],"names":["moment","LAST_PERIOD_KEY","LAST_YEAR_KEY","PERIODS","PERIOD_FORMAT","PERIOD","reduce","acc","ac","id","months","calculateDates","month","period","range","year","calculatedPeriod","lastStartMonth","lastEndMonth","endMonth","set","startMonth","subtract","calculateQuery","type","start_month","format","end_month","last_start_month","last_end_month","calculatePositions","lastReport","item","index","lastIndex","findIndex","lastItem","client_id","hasLast","clientId","legalName","legal_name","currentTotalCents","total","lastPosition","lastTotalCents","calculateChange","currentIndex","icon","steps"],"mappings":"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","sourcesContent":["import moment from 'moment'\nimport { LAST_PERIOD_KEY, LAST_YEAR_KEY, PERIODS } from '../../constants'\nimport { PERIOD_FORMAT } from 'utils'\n\nconst PERIOD = PERIODS.reduce((acc, ac) => ({ ...acc, [ac.id]: ac.months }), {})\n\n/**\n * Calculates dates based on filters\n * @param  {String} month\n * @param  {String} period\n * @param  {String} range\n * @param  {Number} year\n * @returns {Object} moment objects with last range and current range\n */\nexport const calculateDates = ({\n  month,\n  period,\n  range = LAST_YEAR_KEY,\n  year\n}) => {\n  const calculatedPeriod = PERIOD[period] - 1\n  let lastStartMonth\n  let lastEndMonth\n\n  const endMonth = moment()\n    .set('year', year)\n    .set('month', month - 1) // Months on moment start at 0\n\n  const startMonth = moment(endMonth).subtract(calculatedPeriod, 'month')\n\n  if (range === LAST_YEAR_KEY) {\n    lastEndMonth = moment(endMonth).subtract(1, 'year')\n    lastStartMonth = moment(lastEndMonth).subtract(calculatedPeriod, 'month')\n  } else if (range === LAST_PERIOD_KEY) {\n    lastEndMonth = moment(startMonth).subtract(1, 'month')\n    lastStartMonth = moment(lastEndMonth).subtract(calculatedPeriod, 'month')\n  } else {\n    lastEndMonth = endMonth\n    lastStartMonth = startMonth\n  }\n\n  return {\n    lastStartMonth,\n    lastEndMonth,\n    startMonth,\n    endMonth\n  }\n}\n/**\n * Calculate dates to query based on filters\n * @param  {string} month\n * @param  {string} period\n * @param  {string} range\n * @param  {number} year\n * @param  {string} type\n * @returns {Object<String>} Return object with string required for request\n */\nexport const calculateQuery = ({ month, period, range, year, type }) => {\n  const { lastStartMonth, lastEndMonth, startMonth, endMonth } = calculateDates(\n    { month, period, range, year }\n  )\n\n  return {\n    type,\n    start_month: startMonth.format(PERIOD_FORMAT),\n    end_month: endMonth.format(PERIOD_FORMAT),\n    last_start_month: lastStartMonth.format(PERIOD_FORMAT),\n    last_end_month: lastEndMonth.format(PERIOD_FORMAT)\n  }\n}\n\n/**\n * HOF returns a function to map, calculates position based on last report\n * @param  {Object} item\n * @param  {number} index\n */\nexport const calculatePositions = lastReport => (item, index) => {\n  // find for index use client_id\n  const lastIndex = lastReport.findIndex(\n    lastItem => lastItem.client_id === item.client_id\n  )\n\n  // if not find in lastreport, js returns -1\n  const hasLast = lastIndex !== -1\n\n  return {\n    clientId: item.client_id,\n    legalName: item.legal_name,\n    currentTotalCents: item.total,\n    lastPosition: hasLast ? lastIndex + 1 : null,\n    lastTotalCents: hasLast ? lastReport[lastIndex].total : null\n  }\n}\n\n/**\n * Calculate index movement based, and return icon and number steps moved\n * @param  {number} currentIndex\n * @param  {number} lastIndex\n */\nexport const calculateChange = (currentIndex, lastIndex) => {\n  if (lastIndex === null) {\n    return { icon: 'not', steps: '' }\n  }\n  if (currentIndex === lastIndex) {\n    return { icon: 'hold', steps: '' }\n  } else if (currentIndex > lastIndex) {\n    return { icon: 'down', steps: currentIndex - lastIndex }\n  } else if (currentIndex < lastIndex) {\n    return { icon: 'up', steps: lastIndex - currentIndex }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}