{"ast":null,"code":"import _classCallCheck from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/usuario-rtd/Desktop/widget-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { EventEmitter } from 'events';\nimport { camelCase } from 'utils';\nimport AppDispatcher from '../dispatcher';\n\nvar BaseStore =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(BaseStore, _EventEmitter);\n\n  function BaseStore() {\n    var _this;\n\n    _classCallCheck(this, BaseStore);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseStore).call(this));\n    _this.registeredActions = {};\n\n    _this.camelCase = function (object) {\n      return camelCase(object);\n    };\n\n    return _this;\n  } // Emits the string 'change' using the method emit(), it is part of the EventEmitter library\n\n\n  _createClass(BaseStore, [{\n    key: \"emitChange\",\n    value: function emitChange() {\n      this.emit('change');\n    } // Method used when components mount to attach a callback function when the emmiter emmits the string 'change'\n\n  }, {\n    key: \"addChangeListener\",\n    value: function addChangeListener(callback) {\n      this.on('change', callback);\n    } // Method used when components unmount to unattach the callback function and avoid memory leaks\n\n  }, {\n    key: \"removeChangeListener\",\n    value: function removeChangeListener(callback) {\n      this.removeListener('change', callback);\n    } // Static method used to create new Stores, it instatiates this BaseStore,\n    // iterates over the child class actions and registers its own actions to the Dispatcher,\n    // and then returns the new Instance (the new Store)\n\n  }, {\n    key: \"registerAll\",\n    // Register all actions to Dispatcher\n    value: function registerAll() {\n      var _this2 = this;\n\n      var actions = Object.keys(this.actions);\n      actions.forEach(function (key) {\n        var action = _this2.actions[key]; // Keep the reference action each action handler\n\n        _this2.registeredActions[key] = AppDispatcher.register(function (payload) {\n          var data = payload.action;\n          var actionType = data.actionType;\n\n          if (actionType !== key) {\n            return true;\n          } // Invoke callback and emit change in the store only when the keys match\n\n\n          var triggerChange = action.call(_this2, data); // Allow the callback to return false to avoid triggering change event\n\n          if (triggerChange !== false) {\n            _this2.emitChange();\n          }\n\n          return true;\n        });\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      var ClassName = this;\n      this.instance = new ClassName();\n      this.instance.registerAll();\n      return this.instance;\n    }\n  }]);\n\n  return BaseStore;\n}(EventEmitter);\n\nexport default BaseStore;","map":{"version":3,"sources":["/Users/usuario-rtd/Desktop/widget-front/src/stores/baseStore.js"],"names":["EventEmitter","camelCase","AppDispatcher","BaseStore","registeredActions","object","emit","callback","on","removeListener","actions","Object","keys","forEach","key","action","register","payload","data","actionType","triggerChange","call","emitChange","ClassName","instance","registerAll"],"mappings":";;;;;AAAA,SAASA,YAAT,QAA6B,QAA7B;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA,OAAOC,aAAP,MAA0B,eAA1B;;IAEMC,S;;;;;AACJ,uBAAe;AAAA;;AAAA;;AACb;AACA,UAAKC,iBAAL,GAAyB,EAAzB;;AACA,UAAKH,SAAL,GAAiB,UAAAI,MAAM;AAAA,aAAIJ,SAAS,CAACI,MAAD,CAAb;AAAA,KAAvB;;AAHa;AAId,G,CAED;;;;;iCACc;AACZ,WAAKC,IAAL,CAAU,QAAV;AACD,K,CAED;;;;sCACmBC,Q,EAAU;AAC3B,WAAKC,EAAL,CAAQ,QAAR,EAAkBD,QAAlB;AACD,K,CAED;;;;yCACsBA,Q,EAAU;AAC9B,WAAKE,cAAL,CAAoB,QAApB,EAA8BF,QAA9B;AACD,K,CAED;AACA;AACA;;;;AASA;kCACe;AAAA;;AACb,UAAIG,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKF,OAAjB,CAAd;AAEAA,MAAAA,OAAO,CAACG,OAAR,CAAgB,UAAAC,GAAG,EAAI;AACrB,YAAIC,MAAM,GAAG,MAAI,CAACL,OAAL,CAAaI,GAAb,CAAb,CADqB,CAGrB;;AACA,QAAA,MAAI,CAACV,iBAAL,CAAuBU,GAAvB,IAA8BZ,aAAa,CAACc,QAAd,CAAuB,UAAAC,OAAO,EAAI;AAC9D,cAAIC,IAAI,GAAGD,OAAO,CAACF,MAAnB;AACA,cAAII,UAAU,GAAGD,IAAI,CAACC,UAAtB;;AAEA,cAAIA,UAAU,KAAKL,GAAnB,EAAwB;AACtB,mBAAO,IAAP;AACD,WAN6D,CAQ9D;;;AACA,cAAIM,aAAa,GAAGL,MAAM,CAACM,IAAP,CAAY,MAAZ,EAAkBH,IAAlB,CAApB,CAT8D,CAW9D;;AACA,cAAIE,aAAa,KAAK,KAAtB,EAA6B;AAC3B,YAAA,MAAI,CAACE,UAAL;AACD;;AAED,iBAAO,IAAP;AACD,SAjB6B,CAA9B;AAkBD,OAtBD;AAuBD;;;kCAnCqB;AACpB,UAAIC,SAAS,GAAG,IAAhB;AACA,WAAKC,QAAL,GAAgB,IAAID,SAAJ,EAAhB;AACA,WAAKC,QAAL,CAAcC,WAAd;AAEA,aAAO,KAAKD,QAAZ;AACD;;;;EA/BqBxB,Y;;AA+DxB,eAAeG,SAAf","sourcesContent":["import { EventEmitter } from 'events'\nimport { camelCase } from 'utils'\n\nimport AppDispatcher from '../dispatcher'\n\nclass BaseStore extends EventEmitter {\n  constructor () {\n    super()\n    this.registeredActions = {}\n    this.camelCase = object => camelCase(object)\n  }\n\n  // Emits the string 'change' using the method emit(), it is part of the EventEmitter library\n  emitChange () {\n    this.emit('change')\n  }\n\n  // Method used when components mount to attach a callback function when the emmiter emmits the string 'change'\n  addChangeListener (callback) {\n    this.on('change', callback)\n  }\n\n  // Method used when components unmount to unattach the callback function and avoid memory leaks\n  removeChangeListener (callback) {\n    this.removeListener('change', callback)\n  }\n\n  // Static method used to create new Stores, it instatiates this BaseStore,\n  // iterates over the child class actions and registers its own actions to the Dispatcher,\n  // and then returns the new Instance (the new Store)\n  static getInstance () {\n    let ClassName = this\n    this.instance = new ClassName()\n    this.instance.registerAll()\n\n    return this.instance\n  }\n\n  // Register all actions to Dispatcher\n  registerAll () {\n    let actions = Object.keys(this.actions)\n\n    actions.forEach(key => {\n      let action = this.actions[key]\n\n      // Keep the reference action each action handler\n      this.registeredActions[key] = AppDispatcher.register(payload => {\n        let data = payload.action\n        let actionType = data.actionType\n\n        if (actionType !== key) {\n          return true\n        }\n\n        // Invoke callback and emit change in the store only when the keys match\n        let triggerChange = action.call(this, data)\n\n        // Allow the callback to return false to avoid triggering change event\n        if (triggerChange !== false) {\n          this.emitChange()\n        }\n\n        return true\n      })\n    })\n  }\n}\n\nexport default BaseStore\n"]},"metadata":{},"sourceType":"module"}