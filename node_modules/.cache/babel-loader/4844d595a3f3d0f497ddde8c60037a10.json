{"ast":null,"code":"/*!\n * VerbalExpressions JavaScript Library v0.3.0\n * https://github.com/VerbalExpressions/JSVerbalExpressions\n *\n *\n * Released under the MIT license\n * http://opensource.org/licenses/MIT\n */\n\n/**\n* Define the VerbalExpression class.\n* @class\n*/\n(function verbalExpressionIIFE(root) {\n  // Constants\n  var MODULE_NAME = 'VerEx';\n  /**\n  * I am the constructor function.\n  * @constructor\n  * @alias VerEx\n  * @return {RegExp} A new instance of RegExp with injected methods\n  */\n\n  function VerbalExpression() {\n    var verbalExpression = new RegExp(); // Add all the class methods\n\n    VerbalExpression.injectClassMethods(verbalExpression); // Return the new object.\n\n    return verbalExpression;\n  }\n  /**\n  * @param {RegExp} verbalExpression An instance of RegExp on which to add VerbalExpressions methods\n  * @return {RegExp} A new instance of RegExp with injected methods\n  */\n\n\n  VerbalExpression.injectClassMethods = function injectClassMethods(verbalExpression) {\n    var method; // Loop over all the prototype methods\n\n    for (method in VerbalExpression.prototype) {\n      // Make sure this is a local method.\n      if (VerbalExpression.prototype.hasOwnProperty(method)) {\n        // Add the method\n        verbalExpression[method] = VerbalExpression.prototype[method];\n      }\n    }\n\n    return verbalExpression;\n  };\n  /**\n  * Define the class methods.\n  */\n\n\n  VerbalExpression.prototype = {\n    // Variables to hold the whole\n    // expression construction in order\n    _prefixes: '',\n    _source: '',\n    _suffixes: '',\n    _modifiers: 'gm',\n    // default to global multiline matching\n\n    /**\n    * Sanitation function for adding anything safely to the expression\n    * @param {String} value string to sanitize\n    * @return {String} sanitized value\n    */\n    sanitize: function sanitize(value) {\n      var reRegExpEscape;\n\n      if (value.source) {\n        return value.source;\n      }\n\n      if (typeof value === 'number') {\n        return value;\n      } // Regular expression meta characters, URL: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp\n\n\n      reRegExpEscape = /([\\].|*?+(){}^$\\\\:=[])/g; // Escape RegExp special characters only\n      // $& => Last match, URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch\n\n      return value.replace(reRegExpEscape, '\\\\$&');\n    },\n\n    /**\n    * Function to add stuff to the expression. Also compiles the new expression so it's ready to be used.\n    * @param {string} value literal expression, not sanitized\n    * @return {VerbalExpression} Freshly recompiled instance of VerbalExpression\n    */\n    add: function add(value) {\n      this._source += value || '';\n      this.compile(this._prefixes + this._source + this._suffixes, this._modifiers);\n      return this;\n    },\n\n    /**\n    * Control start-of-line matching\n    * @param {Boolean} enable Control start-of-line matching\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    startOfLine: function startOfLine(enable) {\n      enable = enable !== false;\n      this._prefixes = enable ? '^' : '';\n      return this.add();\n    },\n\n    /**\n    * Control end-of-line matching\n    * @param {Boolean} enable Control end-of-line matching\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    endOfLine: function endOfLine(enable) {\n      enable = enable !== false;\n      this._suffixes = enable ? '$' : '';\n      return this.add();\n    },\n\n    /**\n    * We try to keep the syntax as user-friendly as possible. So we can use the \"normal\" behaviour to split the \"sentences\" naturally.\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    then: function then(value) {\n      value = this.sanitize(value);\n      return this.add('(?:' + value + ')');\n    },\n\n    /**\n    * And because we can't start with \"then\" function, we create an alias to be used as the first function of the chain.\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    find: function find(value) {\n      return this.then(value);\n    },\n\n    /*\n    * Maybe is used to add values with ?\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    maybe: function maybe(value) {\n      value = this.sanitize(value);\n      return this.add('(?:' + value + ')?');\n    },\n\n    /**\n    * Any character any number of times\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    anything: function anything() {\n      return this.add('(?:.*)');\n    },\n\n    /**\n    * Anything but these characters\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    anythingBut: function anythingBut(value) {\n      value = this.sanitize(value);\n      return this.add('(?:[^' + value + ']*)');\n    },\n\n    /**\n    * Any character at least one time\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    something: function something() {\n      return this.add('(?:.+)');\n    },\n\n    /**\n    * Any character at least one time except for these characters\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    somethingBut: function somethingBut(value) {\n      value = this.sanitize(value);\n      return this.add('(?:[^' + value + ']+)');\n    },\n\n    /**\n    * Shorthand function for the String.replace function to give more logical flow if, for example, we're doing multiple replacements on one regexp.\n    * @param {String} source string to search for\n    * @param {String} value value to replace with\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    replace: function replace(source, value) {\n      source = source.toString();\n      return source.replace(this, value);\n    },\n    /// Add regular expression special ///\n    /// characters                     ///\n\n    /**\n    * Line break\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    lineBreak: function lineBreak() {\n      return this.add('(?:\\\\r\\\\n|\\\\r|\\\\n)'); // Unix + Windows CRLF\n    },\n\n    /**\n    * And a shorthand for html-minded\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    br: function br() {\n      return this.lineBreak();\n    },\n\n    /**\n    * Tab (duh?)\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    tab: function tab() {\n      return this.add('\\\\t');\n    },\n\n    /**\n    * Any alphanumeric\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    word: function word() {\n      return this.add('\\\\w+');\n    },\n\n    /**\n    * Any digit\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    digit: function digit() {\n      this.add('\\\\d');\n      return this;\n    },\n\n    /**\n    * Any whitespace\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    whitespace: function whitespace() {\n      return this.add('\\\\s');\n    },\n\n    /**\n    * Any given character\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    anyOf: function anyOf(value) {\n      value = this.sanitize(value);\n      return this.add('[' + value + ']');\n    },\n\n    /**\n    * Shorthand\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    any: function any(value) {\n      return this.anyOf(value);\n    },\n\n    /**\n    * Usage: .range( from, to [, from, to ... ] )\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    range: function range() {\n      var length = arguments.length; // Create a string buffer instead of concatenating on iteration\n\n      var buffer = new Array(length / 2);\n      var index = 0;\n      var i = 0;\n      var from;\n      var to;\n      buffer[index++] = '[';\n\n      while (i < length) {\n        from = this.sanitize(arguments[i++]);\n        to = this.sanitize(arguments[i++]);\n        buffer[index++] = from + '-' + to;\n      }\n\n      buffer[index++] = ']';\n      return this.add(buffer.join(''));\n    },\n    /// Modifiers      ///\n\n    /**\n    * Modifier abstraction\n    * @param {String} modifier modifier to add\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    addModifier: function addModifier(modifier) {\n      if (this._modifiers.indexOf(modifier) === -1) {\n        this._modifiers += modifier;\n      }\n\n      return this.add();\n    },\n\n    /**\n    * Remove modifier\n    * @param {String} modifier modifier to remove\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    removeModifier: function removeModifier(modifier) {\n      this._modifiers = this._modifiers.replace(modifier, '');\n      return this.add();\n    },\n\n    /**\n    * Case-insensitivity modifier\n    * @param {Boolean} enable Control case-insensitive matching\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    withAnyCase: function withAnyCase(enable) {\n      return enable !== false ? this.addModifier('i') : this.removeModifier('i');\n    },\n\n    /**\n    * Default behaviour is with \"g\" modifier, so we can turn this another way around than other modifiers\n    * @param {Boolean} enable Control global matching\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    stopAtFirst: function stopAtFirst(enable) {\n      return enable !== false ? this.removeModifier('g') : this.addModifier('g');\n    },\n\n    /**\n    * Multiline, also reversed\n    * @param {Boolean} enable Control multi-line matching\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    searchOneLine: function searchOneLine(enable) {\n      return enable !== false ? this.removeModifier('m') : this.addModifier('m');\n    },\n\n    /**\n    * Repeats the previous item exactly n times or between n and m times.\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    repeatPrevious: function repeatPrevious() {\n      var value;\n      var reIsInteger = /\\d+/;\n      var length = arguments.length;\n      var values = new Array(length);\n      var i = 0;\n      var j = 0;\n\n      for (i = 0; i < length; i++) {\n        if (reIsInteger.test(arguments[i])) {\n          values[j++] = arguments[i];\n        }\n      }\n\n      if (j > 0) {\n        // Set the new length of the array, thus reducing to the elements that have content\n        values.length = j;\n        value = '{' + values.join(',') + '}';\n      }\n\n      return this.add(value);\n    },\n\n    /**\n    * Repeats the previous at least once\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    oneOrMore: function oneOrMore() {\n      return this.add('+');\n    },\n    /// Loops  ///\n\n    /**\n    * Matches the value zero or more times\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    multiple: function multiple(value) {\n      // Use expression or string\n      value = value.source || this.sanitize(value);\n\n      if (arguments.length === 1) {\n        this.add('(?:' + value + ')*');\n      }\n\n      if (arguments.length > 1) {\n        this.add('(?:' + value + ')');\n        this.add('{' + arguments[1] + '}');\n      }\n\n      return this;\n    },\n\n    /**\n    * Adds alternative expressions\n    * @param {String} value value to find\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    or: function or(value) {\n      this._prefixes += '(?:';\n      this._suffixes = ')' + this._suffixes;\n      this.add(')|(?:');\n\n      if (value) {\n        this.then(value);\n      }\n\n      return this;\n    },\n\n    /**\n    * Starts a capturing group\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    beginCapture: function beginCapture() {\n      // Add the end of the capture group to the suffixes for now so compilation continues to work\n      this._suffixes += ')';\n      return this.add('(');\n    },\n\n    /**\n    * Ends a capturing group\n    * @return {VerbalExpression} Same instance of VerbalExpression to allow method chaining\n    */\n    endCapture: function endCapture() {\n      // Remove the last parentheses from the _suffixes and add to the regex itself\n      this._suffixes = this._suffixes.substring(0, this._suffixes.length - 1);\n      return this.add(')');\n    },\n\n    /**\n    * Convert to RegExp object\n    * @return {RegExp} Converted RegExp instance\n    */\n    toRegExp: function toRegExp() {\n      var array = this.toString().match(/\\/(.*)\\/([gimuy]+)?/);\n      return new RegExp(array[1], array[2]);\n    }\n  };\n  /**\n  * @return {VerbalExpression} Returns a new instance of VerbalExpressions\n  */\n\n  function createVerbalExpression() {\n    return new VerbalExpression();\n  } // UMD (Universal Module Definition), URL: https://github.com/umdjs/umd\n  // Supports AMD, CommonJS and the browser\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    // Node.js Module\n    module.exports = createVerbalExpression;\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD Module\n    define(MODULE_NAME, [], function define() {\n      return VerbalExpression;\n    });\n  } else {\n    // Browser\n    root[MODULE_NAME] = createVerbalExpression;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}